# -*- coding: utf-8 -*-
"""DFS_queens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1puD0kHn_0jLIZbtEOzNW4Atp2JNHcaYB

This is the notebook version of the code. I will use this to explain the homework.  I used parts of the code from: https://www.sanfoundry.com/python-program-solve-n-queen-problem-without-recursion/

As we did in class, we will represent the board as a one-dimensional array where each position in the arrray is the n'th queen's column value. So if the array is: [1, 3, 0, 2], then the first queen is in position 1 (from 0--3), the second queen is in position 3 (the last column), the third queen is in the first column and the last queen is the in the second position.
"""

columns = [] #columns is the locations for each of the queens
# columns[r] is a number c if a queen is placed at row r and column c.
size = int(input('Enter n: '))
from ipaddress import collapse_addresses
from json.encoder import INFINITY
import math
import random #hint -- you will need this for the following code: column=random.randrange(0,size)

"""Let's setup one iteration of the British Museum algorithm-- we'll put down 4 queens randomly."""

def place_n_queens(size):
    columns.clear()
    row = 0
    while row < size:
        column=random.randrange(0,size)
        columns.append(column)
        row+=1

place_n_queens(size)

"""Now, we can print the result with a simple loop:"""

def display():
    for row in range(len(columns)):
        for column in range(size):
            if column == columns[row]:
                print('â™›', end=' ')
            else:
                print(' .', end=' ')
        print()

# place_n_queens(size)
# display()
print(columns)

"""This of course is not necessary legal, so we'll write a simple DFS search with backtracking:"""

def solve_queen(size):
    columns.clear()
    number_of_moves = 0 #where do I change this so it counts the number of Queen moves?
    number_of_iterations = 0  
    row = 0
    column = 0
    # iterate over rows of board
    while True:
        #place queen in next row
        ''''print(columns)
        print("I have ", row, " number of queens put down")
        display()
        print(number_of_moves)'''
        while column < size:
            number_of_iterations+=1
            number_of_moves += 1
            if next_row_is_safe(column):
                place_in_next_row(column)
                row += 1
                column = 0
                break
            else:
                column += 1
        # if I could not find an open column or if board is full
        if (column == size or row == size):
            number_of_iterations+=1
            number_of_moves += 1
            # if board is full, we have a solution
            if row == size:
                # print("I did it! Here is my solution")
                # display()
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # I couldn't find a solution so I now backtrack
            prev_column = remove_in_current_row()
            if (prev_column == -1): #I backtracked past column 1
                print("There are no solutions")
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # try previous row again
            row -= 1
            # start checking at column = (1 + value of column in previous row)
            column = 1 + prev_column

"""This code is nice, but it uses three functions:

1. place_in_next_row

2. remove_in_current_row

3. next_row_is_safe

That we now have to define


"""

def place_in_next_row(column):
    columns.append(column)
 
def remove_in_current_row():
    if len(columns) > 0:
        return columns.pop()
    return -1
 
def next_row_is_safe(column):
    row = len(columns) 
    # check column
    for queen_column in columns:
        if column == queen_column:
            return False
 
    # check diagonal
    for queen_row, queen_column in enumerate(columns):
        if queen_column - queen_row == column - row:
            return False
 
    # check other diagonal
    for queen_row, queen_column in enumerate(columns):
        if ((size - queen_column) - queen_row
            == (size - column) - row):
            return False
    return True



# size = int(input('Enter n: '))
num_iterations=0
number_moves = 0
iterations = []
moves = []
print("######################################DFS#########################################")
for i in range(0, 100):
    columns = [] #columns is the locations for each of the queens
    num_iterations, number_moves=solve_queen(size)
    moves.append(number_moves)
    iterations.append(num_iterations)
    display()
    print(columns)
    
  
max_iter = max(iterations)
max_moves = max(moves)
min_iter = min(iterations)
min_moves = min(moves)
avg_iterations = sum(iterations)/100
avg_moves = sum(moves)/100
        
print(f"the avg num of iters for DFS Backtracking are {avg_iterations}")
print(f"the avg num of moves for DFS Backtracking are {avg_moves}")
print(f"the max num of iters for DFS Backtracking are {max_iter}")
print(f"the max num of moves for DFS Backtracking are {max_moves}")
print(f"the min num of iters for DFS Backtracking are {min_iter}")
print(f"the min num of moves for DFS Backtracking are {min_moves}")
# print(num_iterations)
# print(number_moves)
print(columns)

#reset variables for next algorithm
del iterations
del moves
del max_iter
del max_moves
del min_iter
del min_moves
del avg_iterations
del avg_moves
display()
print(columns)
"""Now what?  Can you implement the British Museum Algorithm?  How many iterations did it take to solve the 4 queens problem?  How many did it take to solve the 8 queens (if at all)?"""

print("######################################British Museum Algorithm#########################################")
def check_if_correct(columns):
    correct = True
    temp_cols = columns.copy()
    columns.clear()
    for i in temp_cols:
        correct = correct & next_row_is_safe(i)
        if not correct:
            return correct
        place_in_next_row(i)
    return correct


def BM(columns):
    #set
    correct = False
    num_of_iterations = 0
    num_of_moves = 0
    while(not correct):
        num_of_iterations+=1
        num_of_moves+=size
        #Randomly place queens and check if placement is a solution
        place_n_queens(size)
        correct = check_if_correct(columns)
    return num_of_iterations, num_of_moves

# num_of_iterations = 0
# num_of_moves = 0

iterations = []
moves = []
#because 100 loops was taking way too long i did 10 loops.
num_of_loops = 10
for i in range(num_of_loops):
    iters, mvs = BM(columns)
    iterations.append(iters)
    moves.append(mvs)
    display()
    print(columns)

max_iter = max(iterations)
max_moves = max(moves)
min_iter = min(iterations)
min_moves = min(moves)
avg_iterations = math.ceil(sum(iterations)/num_of_loops)
avg_moves = math.ceil(sum(moves)/num_of_loops)
        
print(f"the avg num of iters for British Museum Algorithm are {avg_iterations}")
print(f"the avg num of moves for British Museum Algorithm are {avg_moves}")
print(f"the max num of iters for British Museum Algorithm are {max_iter}")
print(f"the max num of moves for British Museum Algorithm are {max_moves}")
print(f"the min num of iters for British Museum Algorithm are {min_iter}")
print(f"the min num of moves for British Museum Algorithm are {min_moves}")

#reset variables for next algorithm
del iterations
del moves
del max_iter
del max_moves
del min_iter
del min_moves
del avg_iterations
del avg_moves
del mvs
del iters
del i 
del num_iterations
del number_moves

display()
print(columns)
print("######################################Heuristic Repair/Stochastic Search/Hill Climbing#########################################")


def find_threats(columns):
    #check the column
    count = 0
    row = 0
    #use the same logic for diagonals for checking correctness, now if it isn't correct add to count.
    for col in columns:
        for i in range(len(columns)):
            if col == columns[i] and i != row:
                count += 1
        # check the diagonal
        for queen_row, queen_column in enumerate(columns):
            if queen_column - queen_row == col - row and (queen_column != col and queen_row != row):
                count += 1
        # check the reverse diagonal
        for queen_row, queen_column in enumerate(columns):
            if ((size - queen_column) - queen_row
                == (size - col) - row) and (queen_column != col and queen_row != row):
                count += 1
        row+=1
    return count/2


def arrays_are_equal(arr1,arr2):
    for i in range(len(arr1)):
        if arr1[i] != arr2[i]:
            return False 
    return True

def hill_climbing(columns):
    hill_num_of_moves = len(columns)
    place_n_queens(len(columns))
    previous_heuristic = find_threats(columns)
    min = previous_heuristic
    hill_iters = 0
    hill_current_num_of_iterations = 0
    hill_max_iterations = 300
    while True:
        hill_iters+=1
        hill_current_num_of_iterations+=1
        col_copy = columns.copy()
        we_the_best = columns.copy()
        
        #check for all states which are 1 move (horizontal,vertical, and diagonal) away from this state
        for i in range(len(columns)):
            for j in range(len(columns)):
                temp = col_copy[i]
                col_copy[i] = j
                if (not arrays_are_equal(col_copy,columns)):
                    #find the current heuristic value
                    h = find_threats(col_copy)
                    #WOOT WOOT FOUND THE SOLUTION
                    if(h == 0):                     
                        columns = col_copy
                        return iters,hill_num_of_moves
                    ##awww need to move on to the next iteration
                    if(h <= min):
                        min = h
                        we_the_best = col_copy.copy()
                col_copy[i] = temp 
        #when the previous heuristic value is the same as the current one or when the num of iterations maxes out, throw out everything and start again
        if(hill_current_num_of_iterations >= hill_max_iterations or previous_heuristic == min):
            place_n_queens(len(columns))
            #reset current num of iterations for this board.
            hill_current_num_of_iterations = 0
            hill_num_of_moves += len(columns) 
            previous_heuristic = find_threats(columns)
            min = previous_heuristic
            continue
        hill_num_of_moves+=1
        previous_heuristic = min
        columns = we_the_best

iterations = []
moves = []
for i in range(num_of_loops):
    iters, mvs = hill_climbing(columns)
    iterations.append(iters)
    moves.append(mvs)
    display()
    print(columns)

max_iter = max(iterations)
max_moves = max(moves)
min_iter = min(iterations)
min_moves = min(moves)
avg_iterations = math.ceil(sum(iterations)/num_of_loops)
avg_moves = math.ceil(sum(moves)/num_of_loops)
        
print(f"the avg num of iters for British Museum Algorithm are {avg_iterations}")
print(f"the avg num of moves for British Museum Algorithm are {avg_moves}")
print(f"the max num of iters for British Museum Algorithm are {max_iter}")
print(f"the max num of moves for British Museum Algorithm are {max_moves}")
print(f"the min num of iters for British Museum Algorithm are {min_iter}")
print(f"the min num of moves for British Museum Algorithm are {min_moves}")
      
      
display()
print(columns)
#reset variables for next algorithm
del iterations
del moves
del max_iter
del max_moves
del min_iter
del min_moves
del avg_iterations
del avg_moves

print("######################################Forward Checking#########################################")



display()
print(columns)